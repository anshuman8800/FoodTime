"use strict";

const bcrypt = require("bcryptjs");
const dotenv = require("dotenv");

const User = require("../models/userSchema");
const Restaurant = require("../models/restaurantSchema");
const Order = require("../models/orderSchema");
const Menu = require("../models/menuSchema");

const nodemailer = require("nodemailer");
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: "foodhub.services2022@gmail.com",
    pass: process.env.PASS,
  },
});

exports.changePassword = async (req, res) => {
  const { otp, password, confirm_password, email } = req.body;

  if (!password.trim()) {
    return res.status(422).json({ error: "Enter some password" });
  }

  try {
    const rootUser = await User.findOne({ email });

    if (rootUser) {
      if (rootUser.otp != otp) {
        return res.status(400).json({ error: "Wrong OTP" });
      } else {
        let hashed_password = await bcrypt.hash(password, 12);
        let hashed_confirm_password = await bcrypt.hash(confirm_password, 12);

        await User.updateOne(
          { email },
          {
            $set: {
              password: hashed_password,
              confirm_password: hashed_confirm_password,
              otp: "0",
            },
          }
        );

        return res
          .status(200)
          .json({ message: "Password changed successfully" });
      }
    }
  } catch (err) {
    return res.status(401).json({ error: "Email doesn't match with any user" });
  }
};

exports.forgotPassword = async (req, res) => {
  const { email } = req.body;

  if (!email.trim()) {
    return res.status(422).json({ error: "Enter valid email" });
  }

  try {
    const userExist = await User.findOne({ email: email });

    if (!userExist) {
      return res
        .status(400)
        .json({ error: "Email doesn't match with any user" });
    }

    const otp = 100000 + Math.floor(Math.random() * 900000);

    await User.updateOne({ email: email }, { $set: { otp } });
    console.log("otp updated at database");

    const options = {
      from: "foodhub.services2022@gmail.com",
      to: email,
      subject: "Reset password for FoodHub!",
      text: `\nPlease use this One Time Password (OTP) \"${otp}\" to reset your password.\n\nThis email is automatically generated by FoodHub. Please do not reply to this email.\n\nThanks for using our services. We are happy to serve you.\nFoodHub Team`,
    };

    transporter.sendMail(options, function (err, info) {
      if (err) {
        res
          .status(401)
          .json({ error: "Could not send OTP to the given email" });
        console.log(err);
        return;
      }
      res.status(200).json({ message: "Sent: " + info.response });
      console.log("Sent: " + info.response);
    });
  } catch (err) {
    console.log(err);
  }
};

exports.changePasswordRestaurant = async (req, res) => {
  const { otp, password, confirm_password, email } = req.body;

  if (!password.trim()) {
    return res.status(422).json({ error: "Enter some password" });
  }

  try {
    const rootRestaurant = await Restaurant.findOne({ email });

    if (rootRestaurant) {
      if (rootRestaurant.otp != otp) {
        return res.status(400).json({ error: "Wrong OTP" });
      } else {
        let hashed_password = await bcrypt.hash(password, 12);
        let hashed_confirm_password = await bcrypt.hash(confirm_password, 12);

        await Restaurant.updateOne(
          { email },
          {
            $set: {
              password: hashed_password,
              confirm_password: hashed_confirm_password,
              otp: "0",
            },
          }
        );

        return res
          .status(200)
          .json({ message: "Password changed successfully" });
      }
    }
  } catch (err) {
    return res
      .status(401)
      .json({ error: "Email doesn't match with any restaurant" });
  }
};

exports.forgotPasswordRestaurant = async (req, res) => {
  const { email } = req.body;

  if (!email.trim()) {
    return res.status(422).json({ error: "Enter valid email" });
  }

  try {
    const restaurantExist = await Restaurant.findOne({ email: email });

    if (!restaurantExist) {
      return res
        .status(400)
        .json({ error: "Email doesn't match with any restaurant" });
    }

    const otp = 100000 + Math.floor(Math.random() * 900000);

    await Restaurant.updateOne({ email: email }, { $set: { otp } });
    console.log("otp updated at database");

    const options = {
      from: "foodhub.services2022@gmail.com",
      to: email,
      subject: "Reset password for FoodHub!",
      text: `\nPlease use this One Time Password (OTP) \"${otp}\" to reset your password.\n\nThis email is automatically generated by FoodHub. Please do not reply to this email.\n\nThanks for using our services. We are happy to serve you.\nFoodHub Team`,
    };

    transporter.sendMail(options, function (err, info) {
      if (err) {
        res
          .status(401)
          .json({ error: "Could not send OTP to the given email" });
        console.log(err);
        return;
      }
      res.status(200).json({ message: "Sent: " + info.response });
      console.log("Sent: " + info.response);
    });
  } catch (err) {
    console.log(err);
  }
};

exports.placeOrder = async (req, res) => {
  const {
    userId,
    restaurantId,
    total_amount,
    delivery_address,
    payment_mode,
    orderItems,
    comment,
  } = req.body;

  try {
    const order = new Order({
      userId,
      restaurantId,
      total_amount,
      delivery_address,
      payment_mode,
      orderItems,
      comment,
    });
    await order.save();

    res.send(order);
    console.log("Order placed successfully");
  } catch (err) {
    res.status(401).send("Could not place order");
    console.log(err);
  }
};

exports.userCurrentOrders = async (req, res) => {
  const { userId } = req.body;
  try {
    const userCurrentOrders = await Order.find({
      userId,
      orderStatus: "placed",
    })
      .populate("restaurantId")
      .sort({ updatedAt: -1 });

    if (!userCurrentOrders) {
      throw new Error("Current orders not available");
    }

    res.send(userCurrentOrders);
    console.log(`Current orders fetched successfully.`);
  } catch (err) {
    res.status(401).send("Unauthorized: Unknown error");
    console.log(err);
  }
};

exports.userPreviousOrders = async (req, res) => {
  const { userId } = req.body;
  try {
    const userPreviousOrders = await Order.find({
      userId,
      orderStatus: "closed",
    })
      .populate("restaurantId")
      .sort({ updatedAt: -1 });

    if (!userPreviousOrders) {
      throw new Error("Previous orders not available");
    }

    res.send(userPreviousOrders);
    console.log(`Previous orders fetched successfully.`);
  } catch (err) {
    res.status(401).send("Unauthorized: Unknown error");
    console.log(err);
  }
};

exports.restaurantCurrentOrders = async (req, res) => {
  const { restaurantId } = req.body;
  try {
    const restaurantNewOrders = await Order.find({
      restaurantId,
      orderStatus: "placed",
    })
      .populate("userId")
      .sort({ updatedAt: -1 });

    if (!restaurantNewOrders) {
      throw new Error("New orders not available");
    }

    res.send(restaurantNewOrders);
    console.log(`New orders fetched successfully.`);
  } catch (err) {
    res.status(401).send("Unauthorized: Unknown error");
    console.log(err);
  }
};

exports.restaurantPreviousOrders = async (req, res) => {
  const { restaurantId } = req.body;
  try {
    const restaurantAcceptedOrders = await Order.find({
      restaurantId,
      orderStatus: "closed",
    })
      .populate("userId")
      .sort({ updatedAt: -1 });

    if (!restaurantAcceptedOrders) {
      throw new Error("Accepted orders not available");
    }

    res.send(restaurantAcceptedOrders);
    console.log(`Accepted orders fetched successfully.`);
  } catch (err) {
    res.status(401).send("Unauthorized: Unknown error");
    console.log(err);
  }
};

exports.restaurantDetails = async (req, res) => {
  try {
    const rootRestaurant = await Restaurant.findOne({ _id: req.body.id });
    res.send(rootRestaurant);
    console.log(`Restaurant details fetched successfully.`);
  } catch (err) {
    res.status(401).send("Technical error");
    console.log(err);
  }
};

exports.restaurants = async (req, res) => {
  try {
    const restaurant = await Restaurant.find();
    if (!restaurant) {
      throw new Error("No restaurant has been registered");
    }

    res.send(restaurant);
    console.log(`Restaurant list fetched successfully.`);
  } catch (err) {
    res.status(401).send("Unauthorized: Unknown error");
    console.log(err);
  }
};

exports.getUserData = (req, res) => {
  console.log(`Authenticated`);
  res.send(req.rootUser);
};

exports.menu_id = async (req, res) => {
  try {
    const rootRestaurant = await Restaurant.findOne({ _id: req.params.id });
    const menu = await Menu.find({
      restaurant_email: rootRestaurant.email,
      status: "Available",
    });
    if (!menu) {
      throw new Error("No dishes to show");
    }

    res.send(menu);
    console.log(`Menu list fetched successfully.`);
  } catch (err) {
    res.status(401).send("Unauthorized: Unknown error");
    console.log(err);
  }
};

exports.restaurantProfile_id = async (req, res) => {
  try {
    const rootRestaurant = await Restaurant.findOne({ _id: req.params.id });
    const menu = await Menu.find({ restaurant_email: rootRestaurant.email });
    const order = await Order.find({ restaurant_email: rootRestaurant.email });

    res.send({ rootRestaurant, menu, order });
  } catch (err) {
    res.status(404).send("Restaurant not found");
    console.log(err);
  }
};

exports.account = (req, res) => {
  console.log(`Authenticated`);
  res.send(req.rootUser);
};

exports.accountRestaurant = async (req, res) => {
  try {
    const data = req.rootRestaurant;
    const menu = await Menu.find({ restaurant_email: data.email });

    res.send({ data, menu });
    console.log(`Authenticated`);
  } catch (err) {
    res.status(401).send("Unauthorized: Unknown error");
    console.log(err);
  }
};

exports.updateMenu = async (req, res) => {
  const { name, price, status, restaurant_email } = req.body;

  if (!name.trim() || !price || !status.trim()) {
    return res.status(422).json({ error: "Please fill the entries properly" });
  }

  try {
    const dishExist = await Menu.findOne({ name, restaurant_email });

    if (dishExist) {
      await Menu.updateOne(
        { _id: dishExist._id },
        {
          $set: { name, price, status },
        }
      );

      return res.status(201).json({ message: "Dish updated" });
    }

    const dish = new Menu({ name, price, status, restaurant_email });

    await dish.save();

    res.status(201).json({ message: "Dish added to menu" });
  } catch (err) {
    console.log(err);
  }
};

exports.updateAccountRestaurant = async (req, res) => {
  const { name, mobile, address, email, _id } = req.body;

  if (!name.trim() || !mobile || !email.trim() || !address.trim()) {
    return res.status(422).json({ error: "Please fill the entries properly" });
  }

  try {
    const restaurant = await Restaurant.updateOne(
      { _id },
      {
        $set: { name, mobile, email, address },
      }
    );

    res
      .status(201)
      .json({ message: "Restaurant profile updated successfully" });
  } catch (err) {
    console.log(err);
  }
};

exports.updateAccount = async (req, res) => {
  const { name, mobile, address, email, _id } = req.body;

  if (!name.trim() || !mobile || !email.trim() || !address.trim()) {
    return res.status(422).json({ error: "Please fill the entries properly" });
  }

  try {
    const user = await User.updateOne(
      { _id },
      {
        $set: { name, mobile, email, address },
      }
    );

    res.status(201).json({ message: "User profile updated successfully" });
  } catch (err) {
    console.log(err);
  }
};

exports.orderReceived = async (req, res) => {
  const { orderId } = req.body;
  try {
    const user = await Order.updateOne(
      { _id: orderId },
      {
        $set: { orderStatus: "closed" },
      }
    );

    if (!user) {
      res.status(400).json({ error: "Order could not be closed" });
    }
    res.status(201).json({ message: "Order closed successfully" });
  } catch (err) {
    console.log(err);
  }
};

exports.orders = (req, res) => {
  console.log(`Authenticated`);
  res.send(req.rootRestaurant);
};

exports.signin = async (req, res) => {
  const { email, password } = req.body;

  if (!email.trim() || !password.trim()) {
    return res.status(422).json({ error: "Please fill the entries properly" });
  }

  try {
    const userExist = await User.findOne({ email: email });

    if (!userExist) {
      return res.status(400).json({ error: "Invalid credentials" });
    }

    const isMatch = await bcrypt.compare(password, userExist.password);
    const token = await userExist.generateAuthToken();

    res.cookie("jwtoken", token, {
      expires: new Date(Date.now() + 180000000),
      httpOnly: true,
    });

    if (!isMatch) {
      return res.status(400).json({ error: "Invalid credentials" });
    } else {
      console.log("SignIn successful");
      res.json({ message: "SignIn successful" });
    }
  } catch (err) {
    console.log(err);
  }
};

//register using async await
exports.register = async (req, res) => {
  const { name, email, address, mobile, password, confirm_password } = req.body;

  if (
    !name.trim() ||
    !mobile ||
    !address.trim() ||
    !email.trim() ||
    !password.trim() ||
    !confirm_password.trim()
  ) {
    return res.status(422).json({ error: "Please fill the entries properly" });
  }

  if (password != confirm_password) {
    return res.status(422).json({ error: "Password mismatch" });
  }

  try {
    const userExist = await User.findOne({ email: email });
    if (userExist) {
      return res.status(422).json({ error: "User already exists" });
    }

    const user = new User({
      name,
      email,
      address,
      mobile,
      password,
      confirm_password,
    });

    //hashing "password" and "confirm_password" before saving them to the database
    await user.save();

    res.status(201).json({ message: "User registered successfully" });
  } catch (err) {
    console.log(err);
  }
};

exports.signinRestaurant = async (req, res) => {
  const { email, password } = req.body;

  if (!email.trim() || !password.trim()) {
    return res.status(422).json({ error: "Please fill the entries properly" });
  }

  try {
    const restaurantExist = await Restaurant.findOne({ email: email });

    if (!restaurantExist) {
      return res.status(400).json({ error: "Invalid credentials" });
    }

    const isMatch = bcrypt.compare(password, restaurantExist.password);
    const token = await restaurantExist.generateAuthToken();

    res.cookie("jwtoken2", token, {
      expires: new Date(Date.now() + 450000000),
      httpOnly: true,
    });

    if (!isMatch) {
      return res.status(400).json({ error: "Invalid credentials" });
    } else {
      console.log("Restaurant SignIn successful");
      res.json({ message: "Restaurant SignIn successful" });
    }
  } catch (err) {
    console.log(err);
  }
};

exports.registerRestaurant = async (req, res) => {
  const { name, mobile, address, email, password, confirm_password } = req.body;

  if (
    !name.trim() ||
    !mobile ||
    !email.trim() ||
    !address.trim() ||
    !password.trim() ||
    !confirm_password.trim()
  ) {
    return res.status(422).json({ error: "Please fill the entries properly" });
  }

  if (password != confirm_password) {
    return res.status(422).json({ error: "Password mismatch" });
  }

  try {
    const restaurantExist = await Restaurant.findOne({ email: email });
    if (restaurantExist) {
      return res.status(422).json({ error: "Restaurant already exists" });
    }

    const restaurant = new Restaurant({
      name,
      mobile,
      address,
      email,
      password,
      confirm_password,
    });

    //hashing password and confirm_password before saving them to the database
    await restaurant.save();

    res.status(201).json({ message: "Restaurant registered successfully" });
  } catch (err) {
    console.log(err);
  }
};

exports.signout = (req, res) => {
  res.clearCookie("jwtoken", { path: "/" });
  console.log(`Signed out successfully.`);
  res.status(200).send("User signed out successfully.");
};

exports.signoutRestaurant = (req, res) => {
  res.clearCookie("jwtoken2", { path: "/" });
  console.log(`Signed out successfully.`);
  res.status(200).send("Restaurant signed out successfully.");
};
